const std = @import("std");
const InternPool = @import("InternPool.zig");

const Allocator = std.mem.Allocator;
const Air = @This();

pub const Index = enum(u32) { null, _ };
pub const ExtraIndex = enum(u32) { null, _ };

// start and end index into the extra data array
pub const ExtraSlice = struct {
    start: ExtraIndex,
    end: ExtraIndex,
};

// represents a list of node indices, stored flat in the extra data array
// alias to the ExtraIndex that stores the ExtraSlice to the list of indices
pub const Indices = ExtraIndex;

// the analyzed ir is a list of nodes, similar to an abstract syntax tree.
// it is generated by walking the concrete syntax tree and performing
// type analysis, semantic analysis and verification, interning, and desugaring.
// main_token is dropped so the underlying source can be freed, so nodes that
// actually need name information (like identifiers) use an interned string id
// AIR is fully typed, but type information is only stored on leaf nodes that
// need it (or those that transform types) and is recursively resolved
pub const Node = union(enum) {
    // empty node at the beginning - used to fill .null enum slot
    null,

    // leaf nodes - these correspond to simple values and tokens
    // an integer literal, in any base
    integer,
    // a boolean literal, 'true' or 'false'
    bool,

    // bundle literals initialize a value of a bundle type
    // which is either explicitly typed or inferred from context
    bundle_literal: struct {
        // expression node for the bundle type
        // if anonymous, this is .null
        type: InternPool.Index,
        // list of field initializers
        inits: Indices,
    },
    // each initializer in the bundle literal is a named
    // field assignment '.field = expr'
    // main_token is the field name, and the index is the value
    field_init: Index,

    // typed array literal '[expr, expr, ...]'
    array_literal: struct {
        type: InternPool.Index,
        values: Indices,
    },

    // module instantiation literal 'Foo(input=expr, ...)'
    module_literal: struct {
        // module type being instantiated
        type: InternPool.Index,
        // list of input port initializers
        inits: Indices,
    },
    // each input initializer is a named port assignment
    // 'port=expr'
    input_init: struct {
        type: InternPool.Index,
        value: Index,
    },

    // unary prefix operators
    // integer negation
    ineg: Index,
    // bitwise negation
    bnot: Index,
    // logical negation
    lnot: Index,

    // binary operators
    // integer addition
    iadd: Binary,
    // integer subtraction
    isub: Binary,
    // bitwise and
    band: Binary,
    // bitwise or
    bor: Binary,
    // bitwise xor
    bxor: Binary,
    // logical and
    land: Binary,
    // logical or
    lor: Binary,
    // logical exclusive or
    lxor: Binary,
    // logical implication
    limplies: Binary,

    // subscript (array element access by index)
    subscript: struct {
        // expression node for the array
        value: Index,
        // expression node for the index
        index: Index,
    },

    // member (bundle field access by name)
    member: struct {
        // expression node for the bundle
        value: Index,
        // field name
        name: InternPool.Index,
    },

    // definition of an signal 'let signal[: type] = expr'
    // all signals are immutable once defined (SSA form)
    def: struct {
        // extra data containing type and name
        // data type is Signal
        signal: ExtraIndex,
        // value expression node
        value: Index,
    },

    // forward declaration of a signal
    // this is used for (usually sequential) feedback loops
    // main_token is the `decl` which can be used to seek to the name token
    // no value here, so the index is the type
    decl: Signal,

    // yields a value from an expression block
    yield: Index,

    // block of code (list of nodes)
    block: Indices,

    // toplevel list of statements, similar to block
    // but can only hold type declarations and imports
    toplevel: Indices,

    pub const Binary = struct {
        l: Index,
        r: Index,
    };

    pub const Signal = struct {
        type: InternPool.Index,
        name: InternPool.Index,
    };
};

nodes: std.MultiArrayList(Node).Slice,
extra: []const u32,

pub fn deinit(self: *Air, gpa: Allocator) void {
    self.nodes.deinit(gpa);
    gpa.free(self.extra);
}

pub fn extraData(self: *const Air, index: usize, comptime T: type) T {
    const fields = std.meta.fields(T);
    var result: T = undefined;
    inline for (fields, 0..) |field, i| {
        comptime std.debug.assert(field.type == Index);
        @field(result, field.name) = self.extra[index + i];
    }
    return result;
}

pub fn extraSlice(self: *const Air, sl: ExtraSlice) []const u32 {
    const start = @intFromEnum(sl.start);
    const end = @intFromEnum(sl.end);
    return self.extra[start..end];
}
