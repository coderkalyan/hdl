const std = @import("std");
const InternPool = @import("InternPool.zig");

const Allocator = std.mem.Allocator;
const Air = @This();

// Indices are 31 bits so the upper bit can be used to discriminate
// between runtime (air indices) and compile time (intern pool indices)
pub const Index = enum(u31) { null, _ };
pub const ExtraIndex = enum(u32) { null, _ };

pub const Value = packed struct(u32) {
    tag: Tag,
    payload: Payload,

    pub const Tag = enum(u1) {
        index,
        ip,
    };

    pub const Payload = packed union {
        index: Index,
        ip: InternPool.Index,
    };

    pub const Tagged = union(enum) {
        index: Index,
        ip: InternPool.Index,
    };

    pub fn index(i: Index) Value {
        return .{
            .tag = .index,
            .payload = .{ .index = i },
        };
    }

    pub fn ip(i: InternPool.Index) Value {
        return .{
            .tag = .ip,
            .payload = .{ .ip = i },
        };
    }

    pub fn tagged(value: Value) Tagged {
        switch (value.tag) {
            .index => |i| .{ .index = i },
            .ip => |i| .{ .ip = i },
        }
    }
};

// start and end index into the extra data array
pub const ExtraSlice = struct {
    start: ExtraIndex,
    end: ExtraIndex,
};

// represents a list of node indices, stored flat in the extra data array
// alias to the ExtraIndex that stores the ExtraSlice to the list of indices
pub const Indices = ExtraIndex;

// represents a list of values, stored flat in the extra data array
pub const Values = ExtraIndex;

// the analyzed ir is a list of nodes, similar to an abstract syntax tree.
// it is generated by walking the concrete syntax tree and performing
// type analysis, semantic analysis and verification, interning, and desugaring.
// main_token is dropped so the underlying source can be freed, so nodes that
// actually need name information (like identifiers) use an interned string id
// AIR is fully typed, but type information is only stored on leaf nodes that
// need it (or those that transform types) and is recursively resolved
pub const Node = union(enum) {
    // empty node at the beginning - used to fill .null enum slot
    null,

    // leaf nodes - these correspond to simple values and tokens
    // a named identifier (guaranteed to be within scope)
    ident: struct {
        // because the actual scoping information is not preserved,
        // the type that the expression evaluates to is stored here
        type: InternPool.Index,
        // the name of the identifier, guaranteed to be in scope
        // and legal to print verbatim
        name: InternPool.Index,
    },

    // bundle literals initialize a value of a bundle type
    // which is either explicitly typed or inferred from context
    bundle_literal: struct {
        // expression node for the bundle type
        // if anonymous, this is .null
        type: InternPool.Index,
        // list of field initializers
        inits: Values,
    },
    // each initializer in the bundle literal is a named
    // field assignment '.field = expr'
    // main_token is the field name, and the index is the value
    field_init: Value,

    // typed array literal '[expr, expr, ...]'
    array_literal: struct {
        type: InternPool.Index,
        values: Indices,
    },

    // module instantiation literal 'Foo(input=expr, ...)'
    module_literal: struct {
        // module type being instantiated
        type: InternPool.Index,
        // list of input port initializers
        inits: Indices,
    },
    // each input initializer is a named port assignment
    // 'port=expr'
    input_init: struct {
        type: InternPool.Index,
        value: Value,
    },

    // unary prefix operators
    // integer negation
    ineg: Value,
    // bitwise negation
    bnot: Value,
    // logical negation
    lnot: Value,
    // parentheses (structural annotation, no hardware operation)
    paren: Value,

    // binary operators
    // integer addition
    iadd: Binary,
    // integer subtraction
    isub: Binary,
    // bitwise and
    band: Binary,
    // bitwise or
    bor: Binary,
    // bitwise xor
    bxor: Binary,
    // logical and
    land: Binary,
    // logical or
    lor: Binary,
    // logical exclusive or
    lxor: Binary,
    // logical implication
    limplies: Binary,

    // subscript (array element access by index)
    subscript: struct {
        // expression node for the array
        value: Value,
        // expression node for the index
        index: Value,
    },

    // member (bundle field access by name)
    member: struct {
        // expression node for the bundle
        value: Value,
        // field name
        name: InternPool.Index,
    },

    // definition of an signal 'let signal[: type] = expr'
    // all signals are immutable once defined (SSA form)
    def: struct {
        // extra data containing type and name
        // data type is Signal
        signal: ExtraIndex,
        // value expression node
        value: Value,
    },

    // forward declaration of a signal
    // this is used for (usually sequential) feedback loops
    // main_token is the `decl` which can be used to seek to the name token
    // no value here, so the index is the type
    decl: Signal,

    // reference to a module parameter by index
    // the identifier name is also cached here
    param: struct {
        // index of the parameter in the current module scope
        index: u32,
        // type of the underlying parameter (cached)
        // this is equivalent to the type field stored in the
        // module type at the specified index
        type: InternPool.Index,
    },

    // yields a value from an expression block
    yield: Value,

    // block of code (list of nodes)
    block: Indices,

    // toplevel list of statements, similar to block
    // but can only hold type declarations and imports
    toplevel: Indices,

    pub const Binary = struct {
        l: Value,
        r: Value,
    };

    pub const Signal = struct {
        type: InternPool.Index,
        name: InternPool.Index,
    };

    pub const Tag = std.meta.Tag(Node);
};

nodes: std.MultiArrayList(Node).Slice,
extra: []const u32,
body: Index,

pub fn deinit(self: *Air, gpa: Allocator) void {
    self.nodes.deinit(gpa);
    gpa.free(self.extra);
}

pub fn extraData(self: *const Air, index: ExtraIndex, comptime T: type) T {
    // TODO: replace this with the new memcpy based extra data implementation
    const base = @intFromEnum(index);
    const fields = std.meta.fields(T);
    var result: T = undefined;
    inline for (fields, 0..) |field, i| {
        @field(result, field.name) = @enumFromInt(self.extra[base + i]);
    }
    return result;
}

pub fn tag(self: *const Air, index: Index) Node.Tag {
    const i = @intFromEnum(index);
    return self.nodes.items(.tags)[i];
}

pub fn get(self: *const Air, index: Index) Node {
    const i = @intFromEnum(index);
    return self.nodes.get(i);
}

pub fn indices(self: *const Air, ids: Air.Indices) []const Index {
    const slice = self.extraData(ids, Air.ExtraSlice);
    const start: u32 = @intFromEnum(slice.start);
    const end: u32 = @intFromEnum(slice.end);
    return @ptrCast(self.extra[start..end]);
}

pub fn values(self: *const Air, ids: Air.Values) []const Value {
    const slice = self.extraData(ids, Air.ExtraSlice);
    const start: u32 = @intFromEnum(slice.start);
    const end: u32 = @intFromEnum(slice.end);
    return @ptrCast(self.extra[start..end]);
}

pub fn typeOf(self: *const Air, value: Value) InternPool.Index {
    std.debug.assert(value.tag == .index);

    const index = value.payload.index;
    return switch (self.get(index)) {
        .null => unreachable,
        .ident => |ident| ident.type,
        // TODO:is is not necessarily correct, although it works for now
        // to generalize bundle literals, it should be possible to carry
        // around bundle literals as a kind of anonymous literal without
        // coercing it to a specific type
        .bundle_literal => |literal| literal.type,
        // TODO: should fields know their bundle type?
        .field_init => |fld| self.typeOf(fld),
        .array_literal => |literal| literal.type,
        .module_literal => |literal| literal.type,
        .input_init => |input| input.type,
        .ineg => |v| self.typeOf(v),
        .bnot => |v| self.typeOf(v),
        .lnot => .bool,
        .paren => |v| self.typeOf(v),
        .iadd, .isub, .band, .bor, .bxor => |v| self.typeOf(v.l),
        .land, .lor, .lxor, .limplies => .bool,
        // FIXME: implement these two aggregate accessors
        .subscript, .member => unreachable,
        .def => |def| self.extraData(def.signal, Air.Node.Signal).type,
        .decl => |signal| signal.type,
        .param => |param| param.type,
        .yield => |v| self.typeOf(v),
        .block, .toplevel => unreachable,
    };
}
