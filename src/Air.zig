const std = @import("std");
const InternPool = @import("InternPool.zig");
const Type = @import("type.zig").Type;

const Allocator = std.mem.Allocator;
const Air = @This();

// Indices are 31 bits so the upper bit can be used to discriminate
// between runtime (air indices) and compile time (intern pool indices)
pub const Index = enum(u31) { null, _ };
pub const ExtraIndex = enum(u32) { null, _ };

pub const Value = packed struct(u32) {
    tag: Tag,
    payload: Payload,

    pub const Tag = enum(u1) {
        index,
        ip,
    };

    pub const Payload = packed union {
        index: Index,
        ip: InternPool.Index,
    };

    pub const Tagged = union(enum) {
        index: Index,
        ip: InternPool.Index,
    };

    pub fn index(i: Index) Value {
        return .{
            .tag = .index,
            .payload = .{ .index = i },
        };
    }

    pub fn ip(i: InternPool.Index) Value {
        return .{
            .tag = .ip,
            .payload = .{ .ip = i },
        };
    }

    pub fn tagged(value: Value) Tagged {
        return switch (value.tag) {
            .index => .{ .index = value.payload.index },
            .ip => .{ .ip = value.payload.ip },
        };
    }

    pub fn asIndex(value: Value) ?Index {
        return switch (value.tag) {
            .index => value.payload.index,
            .ip => null,
        };
    }

    pub fn asInterned(value: Value) ?InternPool.Index {
        return switch (value.tag) {
            .index => null,
            .ip => value.payload.ip,
        };
    }
};

// start and end index into the extra data array
pub const ExtraSlice = struct {
    start: ExtraIndex,
    end: ExtraIndex,
};

// represents a list of node indices, stored flat in the extra data array
// alias to the ExtraIndex that stores the ExtraSlice to the list of indices
pub const Indices = ExtraIndex;

// represents a list of values, stored flat in the extra data array
pub const Values = ExtraIndex;

// the analyzed ir is a list of nodes, similar to an abstract syntax tree.
// it is generated by walking the concrete syntax tree and performing
// type analysis, semantic analysis and verification, interning, and desugaring.
// main_token is dropped so the underlying source can be freed, so nodes that
// actually need name information (like identifiers) use an interned string id
// AIR is fully typed, but type information is only stored on leaf nodes that
// need it (or those that transform types) and is recursively resolved
pub const Node = union(enum) {
    // empty node at the beginning - used to fill .null enum slot
    null,

    // leaf nodes - these correspond to simple values and tokens

    // A named identifier to be printed verbatim. It is guaranteed
    // to be within scope.
    ident: struct {
        /// Because scope information is not preserved after semantic
        /// analysis, the signal that this identifier corresponds to,
        /// containing, the name and type information, is recorded here.
        signal: Index,
        /// Because the type of the identifier may be requested frequently,
        /// it is cached here to avoid two indirections to check `signal`.
        type: InternPool.Index,
    },

    // bundle literals initialize a value of a bundle type
    // which is either explicitly typed or inferred from context
    bundle_literal: struct {
        // expression node for the bundle type
        // if anonymous, this is .null
        type: InternPool.Index,
        // list of field initializers
        inits: Values,
    },
    // each initializer in the bundle literal is a named
    // field assignment '.field = expr'
    // main_token is the field name, and the index is the value
    field_init: Value,

    // typed array literal '[expr, expr, ...]'
    array_literal: struct {
        type: InternPool.Index,
        inits: Indices,
    },

    // module instantiation literal 'Foo(input=expr, ...)'
    module_literal: struct {
        // module type being instantiated
        type: InternPool.Index,
        // list of input port initializers
        inits: Indices,
    },
    // each input initializer is a named port assignment
    // 'port=expr'
    input_init: struct {
        type: InternPool.Index,
        value: Value,
    },

    // unary prefix operators
    // integer negation
    ineg: Value,
    // bitwise negation
    bnot: Value,
    // logical negation
    lnot: Value,
    // parentheses (structural annotation, no hardware operation)
    paren: Value,

    // binary operators
    // integer addition
    iadd: struct {
        /// `Binary` expression data.
        bin: ExtraIndex,
        /// Type of resulting expression.
        type: InternPool.Index,
    },
    // integer subtraction
    isub: struct {
        /// `Binary` expression data.
        bin: ExtraIndex,
        /// Type of resulting expression.
        type: InternPool.Index,
    },
    // bitwise and
    band: Binary,
    // bitwise or
    bor: Binary,
    // bitwise xor
    bxor: Binary,
    // logical and
    land: Binary,
    // logical or
    lor: Binary,
    // logical exclusive or
    lxor: Binary,
    // logical implication
    limplies: Binary,
    // equality
    eq: Binary,
    // inequality
    ne: Binary,

    /// Extract a single bit from a bit vector or int.
    bit: struct {
        // expression node for the bit vector
        operand: Value,
        // expression node for the index
        index: Value,
    },
    /// Extract multiple bits from a bit vector or int.
    bitslice: struct {
        /// Data about the slice operand and bounds.
        bitslice: ExtraIndex,
        /// Type of the resulting expression.
        type: InternPool.Index,
    },

    // subscript (array element access by index)
    // TODO: rename this to element to distinguish from the
    // other subscript operators (bit-slice and part-slice)
    subscript: struct {
        // expression node for the array
        operand: Value,
        // expression node for the index
        index: Value,
    },

    // bundle field access by name
    field: struct {
        // expression node for the bundle
        operand: Value,
        // field index in the bundle
        index: u32,
    },

    // definition of an signal 'let signal[: type] = expr'
    // all signals are immutable once defined (SSA form)
    def: struct {
        // extra data containing type and name
        // data type is Signal
        signal: ExtraIndex,
        // value expression node
        value: Value,
    },

    // forward declaration of a signal
    // this is used for (usually sequential) feedback loops
    // main_token is the `decl` which can be used to seek to the name token
    // no value here, so the index is the type
    decl: ExtraIndex,

    // reference to a module parameter by index
    // the identifier name is also cached here
    param: struct {
        // index of the parameter in the current module scope
        index: u32,
        // type of the underlying parameter (cached)
        // this is equivalent to the type field stored in the
        // module type at the specified index
        type: InternPool.Index,
    },

    // yields a value from an expression block
    yield: Value,

    // block of code (list of nodes)
    block: Indices,

    // toplevel list of statements, similar to block
    // but can only hold type declarations and imports
    toplevel: Indices,

    pub const Binary = struct {
        l: Value,
        r: Value,
    };

    pub const Signal = struct {
        type: InternPool.Index,
        name: InternPool.Index,
        salt: u32,
    };

    pub const BitSlice = struct {
        operand: Value,
        upper: InternPool.Index,
        lower: InternPool.Index,
    };

    pub const Tag = std.meta.Tag(Node);
};

nodes: std.MultiArrayList(Node).Slice,
extra: []const u32,
body: Index,

pub fn deinit(self: *Air, gpa: Allocator) void {
    self.nodes.deinit(gpa);
    gpa.free(self.extra);
}

pub fn extraData(self: *const Air, index: ExtraIndex, comptime T: type) T {
    // TODO: replace this with the new memcpy based extra data implementation
    const base = @intFromEnum(index);
    const fields = std.meta.fields(T);
    var result: T = undefined;
    inline for (fields, 0..) |field, i| {
        @field(result, field.name) = switch (field.type) {
            u32 => self.extra[base + i],
            Value => @bitCast(self.extra[base + i]),
            inline else => @enumFromInt(self.extra[base + i]),
        };
    }
    return result;
}

pub fn tag(self: *const Air, index: Index) Node.Tag {
    const i = @intFromEnum(index);
    return self.nodes.items(.tags)[i];
}

pub fn get(self: *const Air, index: Index) Node {
    const i = @intFromEnum(index);
    return self.nodes.get(i);
}

pub fn indices(self: *const Air, ids: Air.Indices) []const Index {
    const slice = self.extraData(ids, Air.ExtraSlice);
    const start: u32 = @intFromEnum(slice.start);
    const end: u32 = @intFromEnum(slice.end);
    return @ptrCast(self.extra[start..end]);
}

pub fn values(self: *const Air, ids: Air.Values) []const Value {
    const slice = self.extraData(ids, Air.ExtraSlice);
    const start: u32 = @intFromEnum(slice.start);
    const end: u32 = @intFromEnum(slice.end);
    return @ptrCast(self.extra[start..end]);
}

pub fn typeOf(self: *const Air, pool: *const InternPool, value: Value) InternPool.Index {
    return switch (value.tagged()) {
        .index => |index| self.typeOfIndex(pool, index),
        .ip => |ip| self.typeOfInterned(pool, ip),
    };
}

pub fn typeOfIndex(self: *const Air, pool: *const InternPool, index: Index) InternPool.Index {
    return switch (self.get(index)) {
        .null => unreachable,
        .ident => |ident| ident.type,
        // TODO:is is not necessarily correct, although it works for now
        // to generalize bundle literals, it should be possible to carry
        // around bundle literals as a kind of anonymous literal without
        // coercing it to a specific type
        .bundle_literal => |literal| literal.type,
        // TODO: should fields know their bundle type?
        .field_init => |fld| self.typeOf(pool, fld),
        .array_literal => |literal| literal.type,
        .module_literal => |literal| literal.type,
        .input_init => |input| input.type,
        .ineg => |v| self.typeOf(pool, v),
        .bnot => |v| self.typeOf(pool, v),
        .lnot => .bool,
        .paren => |v| self.typeOf(pool, v),
        .band, .bor, .bxor => |v| self.typeOf(pool, v.l),
        inline .iadd, .isub => |pl| pl.type,
        .land,
        .lor,
        .lxor,
        .limplies,
        .eq,
        .ne,
        => .bool,
        .bit => .b1,
        .bitslice => |bitslice| bitslice.type,
        .field => |*field| field: {
            const ty = self.typeOf(pool, field.operand);
            const bundle = pool.get(ty).ty.bundle;
            break :field bundle.field_types[field.index];
        },
        .subscript => |*subscript| subscript: {
            const ty = self.typeOf(pool, subscript.operand);
            const array = pool.get(ty).ty.array;
            break :subscript array.element_type;
        },
        .def => |def| self.extraData(def.signal, Air.Node.Signal).type,
        .decl => |signal| self.extraData(signal, Air.Node.Signal).type,
        .param => |param| param.type,
        .yield => |v| self.typeOf(pool, v),
        .block, .toplevel => unreachable,
    };
}

pub fn typeOfInterned(_: *const Air, pool: *const InternPool, index: InternPool.Index) InternPool.Index {
    const tv = pool.get(index).tv;
    return tv.ty;
}
