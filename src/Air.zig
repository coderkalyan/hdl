const std = @import("std");
const InternPool = @import("InternPool.zig");

const Allocator = std.mem.Allocator;
const Air = @This();

// Indices are 31 bits so the upper bit can be used to discriminate
// between runtime (air indices) and compile time (intern pool indices)
pub const Index = enum(u31) { null, _ };
pub const ExtraIndex = enum(u32) { null, _ };

pub const Value = packed struct(u32) {
    tag: Tag,
    payload: Payload,

    pub const Tag = enum(u1) {
        index,
        ip,
    };

    pub const Payload = packed union {
        index: Index,
        ip: InternPool.Index,
    };

    pub const Tagged = union(enum) {
        index: Index,
        ip: InternPool.Index,
    };

    pub fn index(i: Index) Value {
        return .{
            .tag = .index,
            .payload = .{ .index = i },
        };
    }

    pub fn ip(i: InternPool.Index) Value {
        return .{
            .tag = .ip,
            .payload = .{ .ip = i },
        };
    }

    pub fn tagged(value: Value) Tagged {
        switch (value.tag) {
            .index => |i| .{ .index = i },
            .ip => |i| .{ .ip = i },
        }
    }
};

// start and end index into the extra data array
pub const ExtraSlice = struct {
    start: ExtraIndex,
    end: ExtraIndex,
};

// represents a list of node indices, stored flat in the extra data array
// alias to the ExtraIndex that stores the ExtraSlice to the list of indices
pub const Indices = ExtraIndex;

// the analyzed ir is a list of nodes, similar to an abstract syntax tree.
// it is generated by walking the concrete syntax tree and performing
// type analysis, semantic analysis and verification, interning, and desugaring.
// main_token is dropped so the underlying source can be freed, so nodes that
// actually need name information (like identifiers) use an interned string id
// AIR is fully typed, but type information is only stored on leaf nodes that
// need it (or those that transform types) and is recursively resolved
pub const Node = union(enum) {
    // empty node at the beginning - used to fill .null enum slot
    null,

    // leaf nodes - these correspond to simple values and tokens
    // an integer literal, in any base
    integer,
    // a boolean literal, 'true' or 'false'
    bool,

    // bundle literals initialize a value of a bundle type
    // which is either explicitly typed or inferred from context
    bundle_literal: struct {
        // expression node for the bundle type
        // if anonymous, this is .null
        type: InternPool.Index,
        // list of field initializers
        inits: Indices,
    },
    // each initializer in the bundle literal is a named
    // field assignment '.field = expr'
    // main_token is the field name, and the index is the value
    field_init: Value,

    // typed array literal '[expr, expr, ...]'
    array_literal: struct {
        type: InternPool.Index,
        values: Indices,
    },

    // module instantiation literal 'Foo(input=expr, ...)'
    module_literal: struct {
        // module type being instantiated
        type: InternPool.Index,
        // list of input port initializers
        inits: Indices,
    },
    // each input initializer is a named port assignment
    // 'port=expr'
    input_init: struct {
        type: InternPool.Index,
        value: Value,
    },

    // unary prefix operators
    // integer negation
    ineg: Value,
    // bitwise negation
    bnot: Value,
    // logical negation
    lnot: Value,
    // parentheses (structural annotation, no hardware operation)
    paren: Value,

    // binary operators
    // integer addition
    iadd: Binary,
    // integer subtraction
    isub: Binary,
    // bitwise and
    band: Binary,
    // bitwise or
    bor: Binary,
    // bitwise xor
    bxor: Binary,
    // logical and
    land: Binary,
    // logical or
    lor: Binary,
    // logical exclusive or
    lxor: Binary,
    // logical implication
    limplies: Binary,

    // subscript (array element access by index)
    subscript: struct {
        // expression node for the array
        value: Value,
        // expression node for the index
        index: Value,
    },

    // member (bundle field access by name)
    member: struct {
        // expression node for the bundle
        value: Value,
        // field name
        name: InternPool.Index,
    },

    // definition of an signal 'let signal[: type] = expr'
    // all signals are immutable once defined (SSA form)
    def: struct {
        // extra data containing type and name
        // data type is Signal
        signal: ExtraIndex,
        // value expression node
        value: Value,
    },

    // forward declaration of a signal
    // this is used for (usually sequential) feedback loops
    // main_token is the `decl` which can be used to seek to the name token
    // no value here, so the index is the type
    decl: Signal,

    // reference to a module parameter by index
    // the identifier name is also cached here
    param: struct {
        // index of the parameter in the current module scope
        index: u32,
        // identifier name of the underlying parameter
        // this is equivalent to the name field stored in the
        // module type at the specified index
        name: InternPool.Index,
    },

    // yields a value from an expression block
    yield: Value,

    // block of code (list of nodes)
    block: Indices,

    // toplevel list of statements, similar to block
    // but can only hold type declarations and imports
    toplevel: Indices,

    pub const Binary = struct {
        l: Value,
        r: Value,
    };

    pub const Signal = struct {
        type: InternPool.Index,
        name: InternPool.Index,
    };
};

nodes: std.MultiArrayList(Node).Slice,
extra: []const u32,
body: Index,

pub fn deinit(self: *Air, gpa: Allocator) void {
    self.nodes.deinit(gpa);
    gpa.free(self.extra);
}

pub fn extraData(self: *const Air, index: usize, comptime T: type) T {
    const fields = std.meta.fields(T);
    var result: T = undefined;
    inline for (fields, 0..) |field, i| {
        comptime std.debug.assert(field.type == Index);
        @field(result, field.name) = self.extra[index + i];
    }
    return result;
}

pub fn extraSlice(self: *const Air, sl: ExtraSlice) []const u32 {
    const start = @intFromEnum(sl.start);
    const end = @intFromEnum(sl.end);
    return self.extra[start..end];
}
